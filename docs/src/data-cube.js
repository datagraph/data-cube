!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.dc=e()}(this,function(){"use strict";function t(t,e){return t(e={exports:{}},e.exports),e.exports}var e=t(function(t){(()=>{const e={dimName:["row","column","page"],shortDimName:["row","col","page"],lettersArray:["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"],timeUnits:new Map([["year","FullYear"],["month","Month"],["day","Date"],["hour","Hours"],["minute","Minutes"],["second","Seconds"],["milli","Milliseconds"]]),copyArray:t=>{const e=t.length,r=new Array(e);for(let n=0;n<e;n++)r[n]=t[n];return r},equalArray:(t,e)=>{var r=t.length;if(r!==e.length)return!1;for(var n=0;n<r;n++)if(t[n]!==e[n])return!1;return!0},equalArrayOfArray:(t,r)=>{if(!Array.isArray(t)||!Array.isArray(r))return!1;const n=t.length;if(n!==r.length)return!1;for(let i=0;i<n;i++){if(!Array.isArray(t[i])||!Array.isArray(r[i]))return!1;if(!e.equalArray(t[i],r[i]))return!1}return!0},copyMap:t=>{const e=new Map;for(let[r,n]of t.entries())e.set(r,n);return e},equalMap:(t,e)=>{if(t.size!==e.size)return!1;const r=e.entries();for(let[e,n]of t.entries()){let[t,i]=r.next().value;if(e!==t||n!==i)return!1}return!0},toMap:(...t)=>{const e=t.length;if(e%2!=0)throw Error("even number of arguments expected");const r=new Map;for(let n=0;n<e;n+=2)r.set(t[n],t[n+1]);if(r.size!==e/2)throw Error("duplicate key");return r},keyMap:t=>{const e=t.length,r=new Map;for(let n=0;n<e;n++){let e=t[n];if(void 0===e||null===e)throw Error(`invalid key: ${e}`);r.set(e,n)}if(r.size!==e)throw Error("duplicate key");return r},simpleRange:t=>{t=r.nonNegInt(t);for(var e=new Array(t),n=0;n<t;n++)e[n]=n;return e},shuffle:t=>{t=r.posInt(t);const n=e.simpleRange(t);for(let e=t-1;e>0;e--){let t=Math.floor(Math.random()*(e+1)),r=n[e];n[e]=n[t],n[t]=r}return n},fill:(t,e)=>{const r=t.length;for(let n=0;n<r;n++)t[n]=e;return t},fillEW:(t,e)=>{const r=t.length;if(e.length!==r)throw Error("shape mismatch");for(let n=0;n<r;n++)t[n]=e[n];return t},isSingle:t=>!Array.isArray(t)||1===t.length,toArray:t=>Array.isArray(t)?t:[t],polarize:t=>Array.isArray(t)?1===t.length?[t[0],!0]:[t,!1]:[t,!0],def:(t,e)=>void 0===t?e:t,addArrayMethod:(t,e)=>{if(t in Array.prototype)throw Error(t+" is already a property of Array.prototype");Object.defineProperty(Array.prototype,t,{value:e,configurable:!0,enumerable:!1,writable:!0})},addArrayGetter:(t,e)=>{if(t in Array.prototype)throw Error(t+" is already a property of Array.prototype");Object.defineProperty(Array.prototype,t,{configurable:!0,enumerable:!1,get:e})},ensureKey:t=>{t._k||(t._k=new Array(3))},ensureLabel:t=>{t._l||(t._l=new Array(3))},copyKey:(t,r,n)=>{if(t._k)for(let i=0;i<3;i++)i!==n&&t._k[i]&&(e.ensureKey(r),r._k[i]=e.copyMap(t._k[i]))},copyLabel:(t,r,n)=>{if(t._l)for(let i=0;i<3;i++)i!==n&&t._l[i]&&(e.ensureLabel(r),r._l[i]=t._l[i])},skeleton:(t,r,n)=>{const i=[];return i._s=e.copyArray(t._s),e.copyKey(t,i,r),e.copyLabel(t,i,n),i},nni:(t,e)=>{if(!Number.isInteger(t))throw Error("integer expected");if(t>=e||t<-e)throw Error("index out of bounds");return t<0?t+e:t},rangeKey:(t,e,r)=>{const n=new Array(r.size);let i=null===t||void 0===t?1:0;const s=null!==e&&void 0!==e;let o=0;for(let l of r.keys())if(i){if(n[o++]=l,s&&l===e){i=2;break}}else if(l===t){if(n[o++]=l,s&&t===e){i=2;break}i=1}if(0===i)throw Error("start key does not exist");if(s&&1===i)throw Error("end-key does not exist or is before start-key");return n.length=o,n},firstKey:(t,e)=>{const r=new Array(t);let n=0;for(let i of e.keys()){if(n===t)break;r[n++]=i}return r.length=n,r},rangeInd:(t,e)=>{if(e<t)throw Error("end less than start");const r=new Array(e-t+1);let n=0;for(let i=t;i<=e;i++)r[n++]=i;return r},indInd:(t,r)=>{const n=t.length,i=new Array(n);for(let s=0;s<n;s++)i[s]=e.nni(t[s],r);return i},keyInd:(t,e)=>{const r=t.length,n=new Array(r);for(let i=0;i<r;i++){let r=e.get(t[i]);if(void 0===r)throw Error("key does not exist");n[i]=r}return n},comparison:t=>{if(void 0!==t&&null!==t){if("asc"===t)return(t,e)=>t-e;if("desc"===t)return(t,e)=>e-t;if("function"==typeof t)return t;throw Error("invalid argument")}},sortInPlace:(t,r)=>t.sort(e.comparison(r)),sortIndex:(t,r)=>{const n=e.simpleRange(t.length);if(void 0===r||null===r)return n.sort((e,r)=>""+t[e]>""+t[r]?1:""+t[r]>""+t[e]?-1:0);if("asc"===r)return n.sort((e,r)=>t[e]-t[r]);if("desc"===r)return n.sort((e,r)=>t[r]-t[e]);if("function"==typeof r)return n.sort((e,n)=>r(t[e],t[n]));throw Error("invalid argument")},sortRank:(t,r)=>{const n=e.sortIndex(t,r),i=t.length;if(0===i)return[];if(1===i)return[0];const s=new Array(i);let o=e.comparison(r);void 0===o&&(o=((t,e)=>""+t>""+e?1:""+e>""+t?-1:0));let l=n[0];s[l]=0;for(let e=1;e<i;e++){let r=n[e];s[r]=0===o(t[l],t[r])?s[l]:e,l=r}return s},timer:t=>{const e=process.hrtime();t();const r=process.hrtime(e);return Math.round((1e9*r[0]+r[1])/1e6)},callUpdate:(t,e,r,n)=>{for(let i of t[e])i(t,r,n)}};{const t=e.lettersArray,r=new Map;for(let e=0;e<t.length;e++)r.set(t[e],e);e.lettersMap=r}const r={int:t=>{if(!Number.isInteger(t))throw Error("integer expected");return t},nonNegInt:t=>{if(!Number.isInteger(t)||t<0)throw Error("non-negative integer expected");return t},posInt:t=>{if(!Number.isInteger(t)||t<=0)throw Error("positive integer expected");return t},nonNegFin:t=>{if(!Number.isFinite(t)||t<0)throw Error("non-negative finite number expected");return t},fin:t=>{if(!Number.isFinite(t))throw Error("finite number expected");return t},number:t=>{if("number"!=typeof t)throw Error("number expected");return t},dim:t=>{if(void 0===(t=r.single(t)))return 0;if(0!==t&&1!==t&&2!==t)throw Error("invalid dimension");return t},single:t=>{if(Array.isArray(t)){if(1!==t.length)throw Error("singleton expected");return t[0]}return t},string:t=>{if("string"!=typeof t)throw Error("string expected");return t},func:t=>{if("function"!=typeof t)throw Error("function expected");return t},argRange:(t,e,r)=>{const n=t.length;if(n<e)throw Error("too few arguments");if(n>r)throw Error("too many arguments");return n}};e.assert=r,t.exports=e})()}),r=t=>{if("string"!=typeof t)throw new TypeError("Expected a string, got "+typeof t);return 65279===t.charCodeAt(0)?t.slice(1):t},n={},i={},s=34,o=10,l=13;function h(t){return new Function("d","return {"+t.map(function(t,e){return JSON.stringify(t)+": d["+e+"]"}).join(",")+"}")}function f(t){var e=new RegExp('["'+t+"\n\r]"),r=t.charCodeAt(0);function f(t,e){var h,f=[],a=t.length,u=0,c=0,g=a<=0,p=!1;function d(){if(g)return i;if(p)return p=!1,n;var e,h,f=u;if(t.charCodeAt(f)===s){for(;u++<a&&t.charCodeAt(u)!==s||t.charCodeAt(++u)===s;);return(e=u)>=a?g=!0:(h=t.charCodeAt(u++))===o?p=!0:h===l&&(p=!0,t.charCodeAt(u)===o&&++u),t.slice(f+1,e-1).replace(/""/g,'"')}for(;u<a;){if((h=t.charCodeAt(e=u++))===o)p=!0;else if(h===l)p=!0,t.charCodeAt(u)===o&&++u;else if(h!==r)continue;return t.slice(f,e)}return g=!0,t.slice(f,a)}for(t.charCodeAt(a-1)===o&&--a,t.charCodeAt(a-1)===l&&--a;(h=d())!==i;){for(var y=[];h!==n&&h!==i;)y.push(h),h=d();e&&null==(y=e(y,c++))||f.push(y)}return f}function a(e){return e.map(u).join(t)}function u(t){return null==t?"":e.test(t+="")?'"'+t.replace(/"/g,'""')+'"':t}return{parse:function(t,e){var r,n,i=f(t,function(t,i){if(r)return r(t,i-1);n=t,r=e?function(t,e){var r=h(t);return function(n,i){return e(r(n),i,t)}}(t,e):h(t)});return i.columns=n||[],i},parseRows:f,format:function(e,r){return null==r&&(r=function(t){var e=Object.create(null),r=[];return t.forEach(function(t){for(var n in t)n in e||r.push(e[n]=n)}),r}(e)),[r.map(u).join(t)].concat(e.map(function(e){return r.map(function(t){return u(e[t])}).join(t)})).join("\n")},formatRows:function(t){return t.map(a).join("\n")}}}var a=f(","),u=a.parse,c=a.parseRows,g=a.format,p=a.formatRows,d=f("\t"),y=d.parse,_=d.parseRows,b=d.format,m=d.formatRows,w=Object.freeze({dsvFormat:f,csvParse:u,csvParseRows:c,csvFormat:g,csvFormatRows:p,tsvParse:y,tsvParseRows:_,tsvFormat:b,tsvFormatRows:m}),v=t(function(t){(()=>{const e=(t,e)=>{console.log(`Fail: ${t}`+(e?`, ${e}`:""))},r=(t,r,n,i)=>{let s;try{s=r()}catch(r){return void e(t,`${i?i+", ":""} error thrown`)}s!==n&&e(t,i)};r.each=((t,e,n)=>{e.forEach(e=>r(t,...e,n))}),r.throw=((t,r)=>{try{r()}catch(t){return}e(t,"expected error but none thrown")}),r.throwEach=((t,e)=>{e.forEach(e=>r.throw(t,e))});const n=t=>{const e=(t,e)=>{if(!Array.isArray(e)||3!==e.length)throw Error(`${t} is not an array of length 3`)};if(!Array.isArray(t))throw Error("not an array");if(!t._data_cube)throw Error("_data_cube not truthy");const r=t._s;e("_s",r);for(let t=0;t<3;t++)if(!Number.isInteger(r[t])||r[t]<0)throw Error(`_s[${t}] not a non-negative integer`);if(r[0]*r[1]*r[2]!==t.length)throw Error("shape not consistent with number of entries");if("_k"in t){const n=t._k;e("_k",n);for(let t=0;t<3;t++)if(n[t]instanceof Map){if(n[t].size!==r[t])throw Error(`size of _k[${t}] not equal to _s[${t}]`);let e=0;for(let r of n[t].values()){if(r!==e)throw Error(`values of _k[${t}] not 0,1,2,...`);e++}}else if(void 0!==n[t])throw Error(`_k[${t}] neither a map nor undefined`)}if("_l"in t){const r=t._l;e("_l",r);for(let t=0;t<3;t++)if("string"==typeof r[t]){if(""===r[t])throw Error(`_l[${t}] an empty string`)}else if(void 0!==r[t])throw Error(`_l[${t}] neither a string nor undefined`)}for(let e of["_b","_a"])if(e in t){const r=t[e];if(!Array.isArray(r))throw Error(`${e} is not an array`);if(0===r.length)throw Error(`${e} is an empty array`);for(let t of r)if("function"!=typeof t)throw Error(`an entry of ${e} is not a function`)}};r.cube=function(t,r){if(arguments.length<2)n(t);else try{n(r)}catch(r){e(t,r.message)}},r.fail=e,t.exports=r})()});return t(function(t){(()=>{const n=e,{assert:i,fill:s,fillEW:o,addArrayMethod:l,keyMap:h,isSingle:f,polarize:a,def:u,toArray:c,copyArray:g,copyMap:p,ensureKey:d,ensureLabel:y,nni:_,copyKey:b,copyLabel:m,skeleton:E,sortInPlace:k,sortIndex:A,sortRank:$,rangeInd:x,keyInd:C,indInd:N,callUpdate:M}=n;l("_helper",n),["_data_cube","_s","_k","_l","_b","_a"].forEach(t=>{if(t in Array.prototype)throw Error(t+" is a property of Array.prototype")});{const t={};["copyWithin","fill","pop","push","reverse","shift","sort","splice","unshift"].forEach(e=>{t[e]=Array.prototype[e],delete Array.prototype[e],l(e,function(){return t[e].apply(this.toArray(),arguments)})})}l("toCube",function(){return this._data_cube||(this._data_cube=!0,this._s=[this.length,1,1]),this}),l("toArray",function(){return this._data_cube&&(delete this._data_cube,delete this._s,this._k&&delete this._k,this._l&&delete this._l,this._b&&delete this._b,this._a&&delete this._a),this}),l("compare",function(t,e){if(this.toCube(),e=u(i.single(e),!0),this===t)return this;let r;if(r=e?t=>{throw Error(t)}:()=>!1,!Array.isArray(t))return r("cube compared to non-array");const s=this.length;if(s!==t.length)return r("number of entries not equal");for(let e=0;e<s;e++)if(this[e]!==t[e])return r(`entries at vector index ${e} not equal`);if(t._data_cube){if(!n.equalArray(this._s,t._s))return r("shape not equal");const e=this._k,i=t._k;if(e){if(!i)return r("keys-indices");for(let t=0;t<3;t++)if(e[t]){if(!i[t])return r(`keys-indices, ${n.dimName[t]}s`);if(!n.equalMap(e[t],i[t]))return r(`${n.dimName[t]} keys not equal`)}else if(i[t])return r("indices-keys")}else if(i)return r("indices-keys");const s=this._l,o=t._l;if(s){if(!o)return r("labels not equal or not used on same dimensions");if(!n.equalArray(s,o))return r("labels not equal or not used on same dimensions")}else if(o)return r("labels not equal or not used on same dimensions")}else{if(1!==this._s[1]||1!==this._s[2])return r("shape not equal");if(this._k)return r("keys-indices");if(this._l)return r("labels not equal or not used on same dimensions")}return this}),l("cube",function(t){if(this.length>3)throw Error("shape cannot have more than 3 entries");const e=void 0===this[0]?1:i.nonNegInt(this[0]),r=void 0===this[1]?1:i.nonNegInt(this[1]),n=void 0===this[2]?1:i.nonNegInt(this[2]),l=new Array(e*r*n);l._data_cube=!0,l._s=[e,r,n];var[t,h]=a(t);return void 0!==t&&(h?s:o)(l,t),l}),l("rand",function(t){t=i.single(t);const e=this.cube(),r=e.length;if(void 0!==t){const n=i.posInt(+t)+1;for(let t=0;t<r;t++)e[t]=Math.floor(Math.random()*n)}else for(let t=0;t<r;t++)e[t]=Math.random();return e}),l("normal",function(t,e){const r=()=>{let t,e,r;for(;;)if((r=(t=2*Math.random()-1)*t+(e=2*Math.random()-1)*e)>0&&r<1)return t*Math.sqrt(-2*Math.log(r)/r)};if(t=+u(i.single(t),0),(e=+u(i.single(e),1))<=0)throw Error("positive number expected (standard deviation)");const n=this.cube(),s=n.length;for(let i=0;i<s;i++)n[i]=r()*e+t;return n}),l("seq",function(t,e){if(2!==this.length)throw Error("2-entry array expected");const[r,s]=this;if(void 0===(t=i.single(t)))t=1;else if(t=+t,!Number.isFinite(t)||0===t)throw Error("finite, non-zero jump expected");const o=(t,e,r)=>{if(t<e&&r<0||t>e&&r>0)throw new Error("stepping in wrong direction")};let l;if(void 0!==(e=i.single(e))){if(!Number.isInteger(t))throw Error("date range: integer jump expected");"week"===e&&(t*=7,e="day");const i=n.timeUnits.get(e);if(!i)throw Error("invalid time unit");const h=t=>{const e=typeof t;let r;if("string"===e||"number"===e)r=new Date(t);else{if(!(t instanceof Date))throw Error("date, string or number expected");r=new Date(t.getTime())}if(!Number.isFinite(r.getTime()))throw Error("invalid start or end date");return r},f="get"+i,a="set"+i,u=h(r),c=h(s),g=u.getTime(),p=c.getTime();if(g===p)l=[u];else{o(g,p,t),l=[];let e=0,r=u,n=g<p?()=>r.getTime()<=p:()=>r.getTime()>=p;for(;n();)l[e++]=r,(r=new Date(r.getTime()))[a](r[f]()+t)}}else if("number"==typeof r)if(i.fin(r),i.fin(s),r===s)l=[r];else{o(r,s,t);const e=Math.floor((Math.abs(s-r)+1e-15)/Math.abs(t))+1;l=new Array(e);for(let n=0;n<e;n++)l[n]=r+n*t}else{if("string"!=typeof r)throw Error("arguments not consistent with number, string or date range");{if(!Number.isInteger(t))throw Error("string range: integer jump expected");if("string"!=typeof s)throw Error("string expected");const e=n.lettersMap.get(r),i=n.lettersMap.get(s);if(void 0===e||void 0===i)throw Error("string range: start or end invalid");if(e===i)l=[r];else{o(e,i,t);const r=n.lettersArray,s=Math.floor((i-e)/t)+1;l=new Array(s);for(let n=0;n<s;n++)l[n]=r[e+n*t]}}}return l}),l("lin",function(t,e){if(2!==this.length)throw Error("2-entry array expected");const r=i.fin(+this[0]),n=i.fin(+this[1]);if(t=+u(i.single(t),10),!Number.isInteger(t))throw Error("number of points: integer expected");if(t<2)throw Error("number of points must be at least 2");if("point"!==(e=u(i.single(e),"point"))&&"step"!==e)throw Error("'point' or 'step' expected");let o,l;if(r===n)o=0,l=s(new Array(t),r);else if(o=(n-r)/(t-1),(l=new Array(t))[0]=r,l[t-1]=n,t>2)for(let e=1;e<t-1;e++)l[e]=r+e*o;return"step"===e?[l,o]:l}),l("grid",function(t,e){if(t=c(t),"value"!==(e=u(i.single(e),"value"))&&"index"!==e&&"both"!==e)throw Error("'value', 'index' or 'both' expected");const r=this.length,n=t.length,s=r*n;let o;if("value"===e||"index"===e){let i;if(o=[s,2].cube(),"value"===e)for(i=0;i<s;i++)o[i]=this[i%r];else for(i=0;i<s;i++)o[i]=i%r;for(let s=0;s<n;s++)if("value"===e)for(let e=0;e<r;e++)o[i++]=t[s];else for(let t=0;t<r;t++)o[i++]=s}else{let e;for(o=[s,4].cube(),e=0;e<s;e++)o[e]=e%r;for(let t=0;t<s;t++,e++)o[e]=this[e%r];for(let t=0;t<n;t++)for(let n=0;n<r;n++)o[e++]=t;for(let i=0;i<n;i++)for(let n=0;n<r;n++)o[e++]=t[i]}return o}),l("shape",function(){return this.toCube(),g(this._s)}),l("$shape",function(t){this.toCube();const e=t;this._b&&M(this,"_b","$shape",[e]);var[t,r]=a(t);let n=1,s=1,o=1;const l=0===this.length;if(void 0===t)n=this.length;else if(r)if(0===(n=i.nonNegInt(t))){if(!l)throw Error("number of entries cannot change")}else s=l?0:i.nonNegInt(this.length/n);else if(2===t.length)if((n=i.nonNegInt(t[0]))*(s=i.nonNegInt(t[1]))==0){if(!l)throw Error("number of entries cannot change")}else o=l?0:i.nonNegInt(this.length/(n*s));else{if(3!==t.length)throw Error("shape must have 1-3 entries");if((n=i.nonNegInt(t[0]))*(s=i.nonNegInt(t[1]))*(o=i.nonNegInt(t[2]))!==this.length)throw Error("number of entries cannot change")}return this._s[0]=n,this._s[1]=s,this._s[2]=o,this._k&&delete this._k,this._l&&delete this._l,this._a&&M(this,"_a","$shape",[e]),this}),l("$$shape",function(t){return this.toCube(),this.$shape(i.single(t)(this.shape(),this)),this}),l("n",function(t){return this.toCube(),t=i.dim(t),this._s[t]}),l("$squeeze",function(){this.toCube(),this._b&&M(this,"_b","$squeeze",[]);const t=this._s.map(t=>1===t?"1":"n").join("");let e;const r=t=>{const r=this[t];this[t]=[r[e[0]],r[e[1]],r[e[2]]]};return"n1n"===t?e=[0,2,1]:"1nn"===t?e=[1,2,0]:"1n1"===t?e=[1,0,2]:"11n"===t&&(e=[2,0,1]),e&&(r("_s"),this._k&&r("_k"),this._l&&r("_l")),this._a&&M(this,"_a","$squeeze",[]),this}),l("tp",function(t){this.toCube();var[t,e]=a(t);if(e){if(void 0!==t)throw Error("invalid permutation");t=[1,0,2]}else{if(3!==t.length)throw Error("invalid permutation");t=t.map(t=>+t);for(let e=0;e<3;e++)if(!t.includes(e))throw Error("invalid permutation")}const{_s:r,_k:n,_l:i}=this,s=r[t[0]],o=r[t[1]],l=r[t[2]],h=[s,o,l].cube(),f=[1,this._s[0],this._s[0]*this._s[1]].vec(t);let u=0;for(let t=0;t<l;t++){let e=t*f[2];for(let t=0;t<o;t++){let r=t*f[1];for(let t=0;t<s;t++)h[u++]=this[t*f[0]+r+e]}}if(n){d(h);for(let e=0;e<3;e++)n[t[e]]&&(h._k[e]=p(n[t[e]]))}if(i){y(h);for(let e=0;e<3;e++)i[t[e]]&&(h._l[e]=i[t[e]])}return h}),l("label",function(t){return this.toCube(),t=i.dim(t),this._l&&this._l[t]||null}),l("$label",function(t,e){this.toCube();const r=t,n=e;if(this._b&&M(this,"_b","$label",[r,n]),t=i.dim(t),void 0===(e=i.single(e))||null===e){const e=this._l;e&&e[t]&&(e[t]=void 0,e[0]||e[1]||e[2]||delete this._l)}else{if(""===(e=""+e))throw Error("label cannot be empty string");y(this),this._l[t]=e}return this._a&&M(this,"_a","$label",[r,n]),this}),l("$$label",function(t,e){return this.toCube(),this.$label(t,i.single(e)(this.label(t),this)),this}),l("key",function(t){if(this.toCube(),t=i.dim(t),this._k){const e=this._k[t];if(e)return[...e.keys()]}return null}),l("$key",function(t,e){this.toCube();const r=t,n=e;if(this._b&&M(this,"_b","$key",[r,n]),t=i.dim(t),1!==(e=c(e)).length||void 0!==e[0]&&null!==e[0]){const r=h(e);if(this._s[t]!==r.size)throw Error("shape mismatch");d(this),this._k[t]=r}else{const e=this._k;e&&e[t]&&(e[t]=void 0,e[0]||e[1]||e[2]||delete this._k)}return this._a&&M(this,"_a","$key",[r,n]),this}),l("$$key",function(t,e){return this.toCube(),this.$key(t,i.single(e)(this.key(t),this)),this}),l("$strip",function(){return this.toCube(),this._b&&M(this,"_b","$strip",[]),delete this._k,delete this._l,this._a&&M(this,"_a","$strip",[]),this}),l("ind",function(t){return this.toCube(),t=i.dim(t),n.simpleRange(this._s[t])}),l("indOrKey",function(t){return this.key(t)||n.simpleRange(this._s[i.dim(t)])}),l("hasKey",function(t,e){this.toCube(),t=i.dim(t),e=i.single(e);const r=this._k,n=!(!r||!r[t]);return void 0===e?n:n&&r[t].has(e)}),l("copy",function(t){if("full"!==(t=u(i.single(t),"full"))&&"core"!==t&&"shell"!==t&&"array"!==t)throw Error("'full', 'core', 'shell' or 'array' expected");if("array"===t)return g(this);const e="shell"===t?new Array(this.length):g(this);if(e.toCube(),this._data_cube&&(e._s[0]=this._s[0],e._s[1]=this._s[1],e._s[2]=this._s[2],"core"!==t&&(this._l&&(y(e),e._l[0]=this._l[0],e._l[1]=this._l[1],e._l[2]=this._l[2]),this._k))){d(e);for(let t=0;t<3;t++)this._k[t]&&(e._k[t]=p(this._k[t]))}return e}),l("$autoType",function(t){this.toCube();const e=t;this._b&&M(this,"_b","$autoType",[e]),t=i.single(t);for(let e=0,r=this.length;e<r;e++){let r,n=this[e];if("string"==typeof n){if(n)if("undefined"===n)n=void 0;else if("null"===n)n=null;else if("true"===n)n=!0;else if("false"===n)n=!1;else if("NaN"===n)n=NaN;else{if(isNaN(r=+n))continue;n=r}else n=t;this[e]=n}}return this._a&&M(this,"_a","$autoType",[e]),this}),l("ent",function(t){return this.toCube(),this[_(i.single(t),this.length)]}),l("$ent",function(t,e){return this.toCube(),this._b&&M(this,"_b","$ent",[t,e]),this[_(i.single(t),this.length)]=i.single(e),this._a&&M(this,"_a","$ent",[t,e]),this}),l("$$ent",function(t,e){return this.toCube(),this.$ent(t,i.single(e)(this.ent(t),this)),this});{const t=(t,e,r)=>void 0===r||null===r?0:t._k&&t._k[e]?i.number(t._k[e].get(r)):_(r,t._s[e]),e=(e,r,n,s)=>t(e,0,i.single(r))+t(e,1,i.single(n))*e._s[0]+t(e,2,i.single(s))*e._s[0]*e._s[1];l("at",function(t,r,n){if(this.toCube(),0===this.length)throw Error("cube has no entries");return this[e(this,t,r,n)]}),l("$at",function(t,r,n,s){if(this.toCube(),this._b&&M(this,"_b","$at",[t,r,n,s]),0===this.length)throw Error("cube has no entries");return this[e(this,t,r,n)]=i.single(s),this._a&&M(this,"_a","$at",[t,r,n,s]),this}),l("$$at",function(t,e,r,n){return this.toCube(),this.$at(t,e,r,i.single(n)(this.at(t,e,r),this)),this})}l("vec",function(t){this.toCube();var[t,e]=a(t);const r=this.length;if(e)return void 0===t||null===t?g(this):[this[_(t,r)]];const n=t.length,i=new Array(n);for(let e=0;e<n;e++)i[e]=this[_(t[e],r)];return i}),l("$vec",function(t,e){this.toCube();const r=t,n=e;this._b&&M(this,"_b","$vec",[r,n]);const i=this.length;var[t,l]=a(t),[e,h]=a(e);if(l)if(void 0===t||null===t)(h?s:o)(this,e);else{if(!h)throw Error("shape mismatch");this[_(t,i)]=e}else{const r=t.length,n=new Array(r);for(let e=0;e<r;e++)n[e]=_(t[e],i);if(h)for(let t=0;t<r;t++)this[n[t]]=e;else{if(e.length!==r)throw Error("shape mismatch");for(let t=0;t<r;t++)this[n[t]]=e[t]}}return this._a&&M(this,"_a","$vec",[r,n]),this}),l("$$vec",function(t,e){return this.toCube(),this.$vec(t,i.single(e)(this.vec(t),this)),this}),l("vecInd",function(t,e,r){this.toCube();const n=this._s,i=[1,n[0],n[0]*n[1]];let s,o=0;for(let l=0;l<3;l++){let h,[f,u]=a(0===l?t:1===l?e:r),c=this._k&&this._k[l];if(u){if(0===n[l])throw Error(`${c?"key":"index"} does not exist`);if(void 0===f||null===f)continue;if(c){if(void 0===(h=c.get(f)))throw Error("key does not exist")}else h=_(f,n[l]);o+=h*i[l]}else{h=c?C(f,c):N(f,n[l]);let t=f.length;if(s){if(t!==s.length)throw Error("shape mismatch");for(let e=0;e<t;e++)s[e]+=h[e]*i[l]}else{s=new Array(t);for(let e=0;e<t;e++)s[e]=h[e]*i[l]}}}if(s){if(o){let t=s.length;for(let e=0;e<t;e++)s[e]+=o}return s}return[o]}),l("rcp",function(t,e,r){this.toCube();const n=this.vecInd(t,e,r),i=n.length,s=new Array(i);for(let t=0;t<i;t++)s[t]=this[n[t]];return s}),l("$rcp",function(t,e,r,n){this.toCube();const i=n;this._b&&M(this,"_b","$rcp",[t,e,r,i]);const s=this.vecInd(t,e,r),o=s.length;var[n,l]=a(n);if(l)for(let t=0;t<o;t++)this[s[t]]=n;else{if(n.length!==o)throw Error("shape mismatch");for(let t=0;t<o;t++)this[s[t]]=n[t]}return this._a&&M(this,"_a","$rcp",[t,e,r,i]),this}),l("$$rcp",function(t,e,r,n){return this.toCube(),this.$rcp(t,e,r,i.single(n)(this.rcp(t,e,r),this)),this}),l("posn",function(t,e){this.toCube(),t=i.dim(t);const r=this.length,[n,s]=this._s;let o;o=0===t?t=>t%n:1===t?t=>Math.floor(t/n)%s:t=>Math.floor(t/(n*s));const l=this.key(t),h=l?t=>l[o(t)]:o;if(Array.isArray(e)){const t=e.length,n=new Array(t);for(let i=0;i<t;i++)n[i]=h(_(e[i],r));return n}return[h(_(e,r))]});{const t=(t,e,r)=>{const n=t._s[e];return 1!==(r=c(r)).length||void 0!==r[0]&&null!==r[0]?t._k&&t._k[e]?[C(r,t._k[e]),!1]:[N(r,n),!1]:[0===n?[]:x(0,n-1),!0]};l("subcube",function(e,r,n,s){if(this.toCube(),"full"!==(s=u(i.single(s),"full"))&&"core"!==s&&"array"!==s)throw Error("'full', 'core', or 'array' expected");const[o,l]=this._s,f=[t(this,0,e),t(this,1,r),t(this,2,n)],a=f[0][0],g=f[1][0],y=f[2][0],_=a.length,b=g.length,w=y.length,v=new Array(_*b*w);let E=0;for(let t=0;t<w;t++){let e=o*l*y[t];for(let t=0;t<b;t++){let r=o*g[t];for(let t=0;t<_;t++)v[E++]=this[a[t]+r+e]}}if("array"===s)return v;if(v.toCube(),v._s[0]=_,v._s[1]=b,v._s[2]=w,"core"===s)return v;if(this._k){d(v);for(let t=0;t<3;t++)this._k[t]&&(v._k[t]=f[t][1]?p(this._k[t]):h(c(0===t?e:1===t?r:n)))}return m(this,v),v});const e=(e,r,n,i,s)=>{const[o,l]=e._s,h=t(e,0,r)[0],f=t(e,1,n)[0],u=t(e,2,i)[0],c=h.length,g=f.length,p=u.length;var[s,d]=a(s);if(!d&&s.length!==c*g*p)throw Error("shape mismatch");let y=0;for(let t=0;t<p;t++){let r=o*l*u[t];for(let t=0;t<g;t++){let n=o*f[t];for(let t=0;t<c;t++)e[h[t]+n+r]=d?s:s[y++]}}};l("$subcube",function(t,r,n,i){return this.toCube(),this._b&&M(this,"_b","$subcube",[t,r,n,i]),e(this,t,r,n,i),this._a&&M(this,"_a","$subcube",[t,r,n,i]),this}),l("$$subcube",function(t,e,r,n){return this.toCube(),this.$subcube(t,e,r,i.single(n)(this.subcube(t,e,r),this)),this});{const t=[(t,e,r)=>t.subcube(e,null,null,r),(t,e,r)=>t.subcube(null,e,null,r),(t,e,r)=>t.subcube(null,null,e,r)],r=[(t,r,n)=>e(t,r,null,null,n),(t,r,n)=>e(t,null,r,null,n),(t,r,n)=>e(t,null,null,r,n)];["row","col","page"].forEach((e,r)=>{l(e,function(e,n){return t[r](this,e,n)}),l("$$"+e,function(t,r){return this.toCube(),this["$"+e](t,i.single(r)(this[e](t),this)),this})}),["$row","$col","$page"].forEach((t,e)=>{l(t,function(n,i){return this.toCube(),this._b&&M(this,"_b",t,[n,i]),r[e](this,n,i),this._a&&M(this,"_a",t,[n,i]),this})});const s=function(e,s,o,l,h,f){let a;if(s.toCube(),l=i.single(l),h=i.single(h),s._k&&s._k[o])a=n.rangeKey(l,h,s._k[o]);else{const t=s._s[o];l=null===l||void 0===l?0:_(l,t),h=null===h||void 0===h?t-1:_(h,t),a=0===t?[]:x(l,h)}return(e?r:t)[o](s,a,f)};["rowSlice","colSlice","pageSlice"].forEach((t,e)=>{l(t,function(t,r,n){return s(!1,this,e,t,r,n)}),l("$$"+t,function(e,r,n){return this.toCube(),this["$"+t](e,r,i.single(n)(this[t](e,r),this)),this})}),["$rowSlice","$colSlice","$pageSlice"].forEach((t,e)=>{l(t,function(r,n,i){return this.toCube(),this._b&&M(this,"_b",t,[r,n,i]),s(!0,this,e,r,n,i),this._a&&M(this,"_a",t,[r,n,i]),this})})}l("head",function(t,e,r,s){this.toCube();const o=new Array(3);for(let s=0;s<3;s++){let l=i.single(0===s?t:1===s?e:r);const h=this._s[s];null===l||void 0===l?l=h:(i.nonNegInt(l),l=Math.min(l,h)),0===l?o[s]=[]:this._k&&this._k[s]?o[s]=n.firstKey(l,this._k[s]):o[s]=x(0,l-1)}return this.subcube(...o,s)})}l("vble",function(t){this.toCube(),t=u(i.single(t),0);const{_s:e,_k:r,_l:s}=this,[o,l,h]=e,[f,a,c]=[0,1,2].map(t=>r&&r[t]?[...r[t].keys()]:n.simpleRange(e[t])),[g,p,d]=[0,1,2].map(t=>s&&s[t]||n.shortDimName[t]);let y;if(-1===t){y=new Array(this.length);let t=0;for(let e=0;e<h;e++){let r=o*l*e,n=c[e];for(let e=0;e<l;e++){let i=o*e,s=a[e];for(let e=0;e<o;e++)y[t++]={[g]:f[e],[p]:s,[d]:n,entry:this[e+i+r]}}}}else if(0===t){y=new Array(l*h);let t=0,e=0;for(let r=0;r<h;r++)for(let n=0;n<l;n++){let i={};i[p]=a[n],i[d]=c[r];for(let t=0;t<o;t++)i[f[t]]=this[e++];y[t++]=i}}else if(1===t){y=new Array(o*h);let t=0;for(let e=0;e<h;e++)for(let r=0;r<o;r++){let n=r+e*o*l,i={};i[g]=f[r],i[d]=c[e];for(let t=0;t<l;t++)i[a[t]]=this[n+t*o];y[t++]=i}}else{if(2!==t)throw Error("invalid dimension");{const t=o*l;y=new Array(t);let e=0,r=-1;for(let n=0;n<l;n++)for(let i=0;i<o;i++){r++;let s={};s[g]=f[i],s[p]=a[n];for(let e=0;e<h;e++)s[c[e]]=this[r+e*t];y[e++]=s}}}return y});{const t=["isInteger","isFinite","isNaN"],e=(t,e)=>{e.forEach(e=>{l(e,function(){this.toCube();const r=this.copy("shell"),n=this.length,i=t[e];for(let t=0;t<n;t++)r[t]=i(this[t]);return r})})};e(Math,["sqrt","cbrt","abs","round","floor","ceil","trunc","sign","exp","expm1","log","log10","log2","log1p","sin","cos","tan","asin","acos","atan","sinh","cosh","tanh","asinh","acosh","atanh"]),e(Number,t);const r=[["neg",t=>-t],["number",t=>+t],["string",t=>""+t],["boolean",t=>!!t],["date",t=>new Date(t)],["not",t=>!t],["typeof",t=>typeof t],["trim",t=>t.trim()],["toLowerCase",t=>t.toLowerCase()],["toUpperCase",t=>t.toUpperCase()],["box",t=>Array.isArray(t)?t:[t]],["unbox",t=>Array.isArray(t)?t[0]:t]];for(let[t,e]of r)l(t,function(){this.toCube();const t=this.copy("shell"),r=this.length;for(let n=0;n<r;n++)t[n]=e(this[n]);return t})}{const t=[["add",(t,e)=>t+e],["sub",(t,e)=>t-e],["mul",(t,e)=>t*e],["div",(t,e)=>t/e],["rem",(t,e)=>t%e],["pow",Math.pow],["atan2",Math.atan2],["hypot",Math.hypot],["eq",(t,e)=>t===e],["neq",(t,e)=>t!==e],["lt",(t,e)=>t<e],["lte",(t,e)=>t<=e],["gt",(t,e)=>t>e],["gte",(t,e)=>t>=e],["lof",Math.min],["gof",Math.max],["toExponential",(t,e)=>t.toExponential(e)],["toFixed",(t,e)=>t.toFixed(e)],["toPrecision",(t,e)=>t.toPrecision(e)],["charAt",(t,e)=>t.charAt(e)],["repeat",(t,e)=>t.repeat(e)],["search",(t,e)=>t.search(e)],["test",(t,e)=>t.test(e)],["and",(t,e)=>t&&e],["or",(t,e)=>t||e]];for(let[e,r]of t)l(e,function(t){this.toCube();const n=arguments.length;if(n>1){let r=this[e](t);for(let t=1;t<n;t++)r=r[e](arguments[t]);return r}var[t,i]=a(t);const s=this.length;let o;if(i){o=this.copy("shell");for(let e=0;e<s;e++)o[e]=r(this[e],t)}else{const e=t.length;if(1===s){o=t.copy("shell");const n=this[0];for(let i=0;i<e;i++)o[i]=r(n,t[i])}else{if(s!==e)throw Error("shape mismatch");o=this.copy("shell");for(let e=0;e<s;e++)o[e]=r(this[e],t[e])}}return o})}l("cond",function(t,e){this.toCube();const r=this.length;var[t,n]=a(t);if(!n&&t.length!==r)throw Error("shape mismatch");var[e,i]=a(e);if(!i&&e.length!==r)throw Error("shape mismatch");const s=this.copy("shell");if(n)if(i)for(let n=0;n<r;n++)s[n]=this[n]?t:e;else for(let n=0;n<r;n++)s[n]=this[n]?t:e[n];else if(i)for(let n=0;n<r;n++)s[n]=this[n]?t[n]:e;else for(let n=0;n<r;n++)s[n]=this[n]?t[n]:e[n];return s});{const t=(t,e,r,n)=>{if(t.toCube(),e=i.single(e),"call"===r)i.func(e);else if("apply"===r)for(let e of t)i.func(e);const s=t.length,o=n.length,l=t.copy("shell");if(0===o)if("method"===r)for(let r=0;r<s;r++)l[r]=t[r][e]();else if("call"===r)for(let r=0;r<s;r++)l[r]=e(t[r]);else for(let e=0;e<s;e++)l[e]=t[e]();else if(o<3){const[i,h]=a(n[0]);if(!h&&i.length!==s)throw Error("shape mismatch");if(1===o)if(h)if("method"===r)for(let r=0;r<s;r++)l[r]=t[r][e](i);else if("call"===r)for(let r=0;r<s;r++)l[r]=e(t[r],i);else for(let e=0;e<s;e++)l[e]=t[e](i);else if("method"===r)for(let r=0;r<s;r++)l[r]=t[r][e](i[r]);else if("call"===r)for(let r=0;r<s;r++)l[r]=e(t[r],i[r]);else for(let e=0;e<s;e++)l[e]=t[e](i[e]);else{const[o,f]=a(n[1]);if(!f&&o.length!==s)throw Error("shape mismatch");if(h)if(f)if("method"===r)for(let r=0;r<s;r++)l[r]=t[r][e](i,o);else if("call"===r)for(let r=0;r<s;r++)l[r]=e(t[r],i,o);else for(let e=0;e<s;e++)l[e]=t[e](i,o);else if("method"===r)for(let r=0;r<s;r++)l[r]=t[r][e](i,o[r]);else if("call"===r)for(let r=0;r<s;r++)l[r]=e(t[r],i,o[r]);else for(let e=0;e<s;e++)l[e]=t[e](i,o[e]);else if(f)if("method"===r)for(let r=0;r<s;r++)l[r]=t[r][e](i[r],o);else if("call"===r)for(let r=0;r<s;r++)l[r]=e(t[r],i[r],o);else for(let e=0;e<s;e++)l[e]=t[e](i[e],o);else if("method"===r)for(let r=0;r<s;r++)l[r]=t[r][e](i[r],o[r]);else if("call"===r)for(let r=0;r<s;r++)l[r]=e(t[r],i[r],o[r]);else for(let e=0;e<s;e++)l[e]=t[e](i[e],o[e])}}else{const i=new Array(o);for(let t=0;t<o;t++){let[e,r]=a(n[t]);if(r)i[t]=(()=>e);else{if(e.length!==s)throw Error("shape mismatch");i[t]=(t=>e[t])}}const h=t=>{const e=new Array(o);for(let r=0;r<o;r++)e[r]=i[r](t);return e};if("method"===r)for(let r=0;r<s;r++)l[r]=t[r][e](...h(r));else if("call"===r)for(let r=0;r<s;r++)l[r]=e(t[r],...h(r));else for(let e=0;e<s;e++)l[e]=t[e](...h(e))}return l};l("method",function(e,...r){return t(this,e,"method",r)}),l("call",function(e,...r){return t(this,e,"call",r)}),l("apply",function(...e){return t(this,null,"apply",e)}),l("$$call",function(e,...r){const n=t(this,e,"call",r);this._b&&M(this,"_b","$call",[n]);for(let t=0,e=this.length;t<e;t++)this[t]=n[t];return this._a&&M(this,"_a","$call",[n]),this})}l("prop",function(t){this.toCube(),t=i.single(t);const e=this.length,r=this.copy("shell");for(let n=0;n<e;n++)r[n]=this[n][t];return r}),l("$prop",function(t,e){this.toCube();const r=t,n=e;this._b&&M(this,"_b","$prop",[r,n]),t=i.single(t);var[e,s]=a(e);const o=this.length;if(s)for(let r=0;r<o;r++)this[r][t]=e;else{if(e.length!==o)throw Error("shape mismatch");for(let r=0;r<o;r++)this[r][t]=e[r]}return this._a&&M(this,"_a","$prop",[r,n]),this}),l("$$prop",function(t,e){this.toCube(),i.single(t),e=i.single(e);const r=this.length,n=new Array(r);for(let t=0;t<r;t++)n[t]=e(this[t],this);return this.$prop(t,n),this}),l("loop",function(...t){this.toCube();let e=this.length;const r=t.length,n=new Array(r),s=new Array(r),o=new Array(r);for(let l=0;l<r;l++){t[l]=c(t[l]);const r=t[l].length;if(0===r)throw Error("non-empty array expected");let h=i.single(t[l][0]);if("function"==typeof h)n[l]="f";else{if("string"!=typeof h)throw Error("string or function expected");if("$"===h[0]){if(2!==r)throw Error("2-entry array expected: property name and new value(s)");n[l]="p",h=h.slice(1)}else n[l]="m"}if(s[l]=h,r>1){o[l]=new Array(r-1);for(let n=1;n<r;n++){const[r,i]=a(t[l][n]);if(i)o[l][n-1]=(()=>r);else{if(r.length!==e){if(1!==e)throw Error("shape mismatch");e=r.length}o[l][n-1]=(t=>r[t])}}}}for(let i=0;i<e;i++){const e=1===this.length?this[0]:this[i];for(let l=0;l<r;l++){const r=s[l],h=t[l].length;"p"===n[l]?e[r]=o[l][0](i):"m"===n[l]?1===h?e[r]():2===h?e[r](o[l][0](i)):3===h?e[r](o[l][0](i),o[l][1](i)):4===h?e[r](o[l][0](i),o[l][1](i),o[l][2](i)):5===h?e[r](o[l][0](i),o[l][1](i),o[l][2](i),o[l][3](i)):e[r](...o[l].map(t=>t(i))):1===h?r(e):2===h?r(e,o[l][0](i)):3===h?r(e,o[l][0](i),o[l][1](i)):4===h?r(e,o[l][0](i),o[l][1](i),o[l][2](i)):5===h?r(e,o[l][0](i),o[l][1](i),o[l][2](i),o[l][3](i)):r(e,...o[l].map(t=>t(i)))}}return this});{const t=(t,e,r,n,s)=>{t.toCube(),e=u(i.single(e),0),r=i.func(i.single(r)),n=i.single(n);const o=t.length;let l,h,f;if(void 0===n){if(!o)throw Error("must supply init if array/cube empty");l=1}else l=0;if(-1===e)if(h=l?t[0]:n,s){f=[o].cube(),l&&(f[0]=h);for(let e=l;e<o;e++)f[e]=h=r(h,t[e],e,t)}else{for(let e=l;e<o;e++)h=r(h,t[e],e,t);(f=[h]).toCube()}else{const[i,o,a]=t._s,u=i*o;if(s)f=t.copy("shell");else{if(0===e)f=[1,o,a].cube();else if(1===e)f=[i,1,a].cube();else{if(2!==e)throw Error("invalid dimension");f=[i,o,1].cube()}b(t,f,e),m(t,f,e)}if(0===e){let e=0;for(let c=0;c<a;c++){let a=u*c;for(let u=0;u<o;u++){let o=i*u;if(h=l?t[o+a]:n,s){l&&(f[o+a]=h);for(let e=l;e<i;e++){let n=e+o+a;f[n]=h=r(h,t[n],e,t)}}else{for(let e=l;e<i;e++)h=r(h,t[e+o+a],e,t);f[e++]=h}}}}else if(1===e){let e=0;for(let c=0;c<a;c++){let a=u*c;for(let u=0;u<i;u++)if(h=l?t[u+a]:n,s){l&&(f[u+a]=h);for(let e=l;e<o;e++){let n=u+e*i+a;f[n]=h=r(h,t[n],e,t)}}else{for(let e=l;e<o;e++)h=r(h,t[u+e*i+a],e,t);f[e++]=h}}}else{if(2!==e)throw Error("invalid dimension");{let e=0;for(let c=0;c<o;c++){let o=i*c;for(let c=0;c<i;c++)if(h=l?t[c+o]:n,s){l&&(f[c+o]=h);for(let e=l;e<a;e++)vInd=c+o+e*u,f[vInd]=h=r(h,t[vInd],e,t)}else{for(let e=l;e<a;e++)h=r(h,t[c+o+e*u],e,t);f[e++]=h}}}}}return f};l("fold",function(e,r,n){return t(this,e,r,n,!1)}),l("cumu",function(e,r,n){return t(this,e,r,n,!0)});const e=[["sum",(t,e)=>t+ +e,0],["prod",(t,e)=>t*e,1],["all",(t,e)=>t&&!!e,!0],["any",(t,e)=>t||!!e,!1],["count",(t,e)=>t+!!e,0],["min",(t,e)=>Math.min(t,e),1/0],["max",(t,e)=>Math.max(t,e),-1/0]];e.forEach(t=>{l(t[0],function(e){return this.fold(e,t[1],t[2])})}),e.forEach(t=>{l("cumu"+t[0][0].toUpperCase()+t[0].slice(1),function(e){return this.cumu(e,t[1],t[2])})}),l("range",function(t){const e=this.min(t),r=this.max(t),n=r.length;for(let t=0;t<n;t++)r[t]-=e[t];return r}),l("sameType",function(t){return this.fold(t,(t,e)=>((e=typeof e)===t||null===t)&&e,null)});const r=t=>t?(t,e,r)=>t[0]<e?[e,r]:t:(t,e,r)=>t[0]>e?[e,r]:t;["minPosn","maxPosn","cumuMinPosn","cumuMaxPosn"].forEach((t,e)=>{l(t,function(t){const n=e%2;let s=this[e>1?"cumu":"fold"](t,r(n),[[n?-1/0:1/0,null]]);const o=s.length;if(-1!==(t=u(i.single(t),0))&&this._k&&this._k[t]){const e=this.key(t);for(let t=0;t<o;t++){let r=s[t][1];s[t]=null===r?null:e[r]}}else for(let t=0;t<o;t++)s[t]=s[t][1];return s})}),["mean","geoMean"].forEach(t=>{l(t,function(e){const r="geoMean"===t,n=this[r?"prod":"sum"](e);if(-1===(e=u(i.single(e),0)))n[0]=r?Math.pow(n[0],1/this.length):n[0]/this.length;else{const t=n.length;let i=1/this._s[e];if(r)for(let e=0;e<t;e++)n[e]=Math.pow(n[e],i);else for(let e=0;e<t;e++)n[e]*=i}return n})}),l("sew",function(t,e){this.toCube(),e=""+u(i.single(e),",");const r=this.fold(t,(t,r)=>`${t}${e}${null===r||void 0===r?"":r}`,"");if(e){const t=e.length,n=r.length;for(let e=0;e<n;e++)r[e]=r[e].slice(t)}return r}),l("var",function(t,e){this.toCube(),t=u(i.single(t),0),e=i.nonNegInt(u(i.single(e),0));const r=this.fold(t,(t,e)=>{const r=t[0]+1,n=e-t[1],i=t[1]+n/r;return[r,i,t[2]+n*(e-i)]},[[0,0,0]]),n=r.length,s=-1===t?this.length:this._s[t];if(s<2)for(let t=0;t<n;t++)r[t]=NaN;else{let t=s-e;for(let e=0;e<n;e++)r[e]=r[e][2]/t}return r}),l("sd",function(t,e){const r=this.var(t,e),n=r.length;for(let t=0;t<n;t++)r[t]=Math.sqrt(r[t]);return r}),l("wrap",function(t,e){if(this.toCube(),t=u(i.single(t),0),"full"!==(e=u(i.single(e),"full"))&&"core"!==e&&"array"!==e)throw Error("'full', 'core', or 'array' expected");let r;if(-1===t)r=g(this),"array"!==e&&r.toCube(),(r=[r]).toCube();else{const[n,i,s]=this._s,o=this._k,l=t=>o&&o[t]?e=>o[t].get(e):t=>t;if(0===t){r=[1,i,s].cube();const t=l(1),n=l(2);for(let s of this.indOrKey(2)){let o=n(s)*i;for(let n of this.indOrKey(1))r[t(n)+o]=this.subcube(null,n,s,e)}}else if(1===t){r=[n,1,s].cube();const t=l(0),i=l(2);for(let s of this.indOrKey(2)){let o=i(s)*n;for(let n of this.indOrKey(0))r[t(n)+o]=this.subcube(n,null,s,e)}}else{if(2!==t)throw Error("invalid dimension");{r=[n,i,1].cube();const t=l(0),s=l(1);for(let i of this.indOrKey(1)){let o=s(i)*n;for(let n of this.indOrKey(0))r[t(n)+o]=this.subcube(n,i,null,e)}}}b(this,r,t),m(this,r,t)}return r})}l("quantile",function(t,e){this.toCube(),t=u(i.single(t),0);var[e,r]=a(e);let o;if(r&&(void 0===e?(e=[0,.25,.5,.75,1],o=!0):e=[e]),!o&&((e=e.number().toArray()).isNaN().any()[0]||e.lt(0).any()[0]||e.gt(1).any()[0]))throw Error("probabilities must be between 0 and 1 (inclusive)");const l=e.length,h=t=>{const r=t.length;if(0===r)return s(new Array(l),NaN);for(let e=0;e<r;e++){let r=+t[e];if(!Number.isFinite(r))return s(new Array(l),NaN);t[e]=r}t.sort(n.comparison("asc"));const i=e.mul(r-1),o=i.floor(),h=i.sub(o);return t.vec(o).mul([1].sub(h)).add(t.vec(i.ceil()).mul(h))};let f;if(-1===t)f=h(g(this)).$key(0,e);else{if(![0,1,2].includes(t))throw Error("invalid dimension");const r=g(this._s);if(r[t]=l,f=r.cube(),b(this,f,t),m(this,f,t),f.$key(t,e),0===t)for(let t of this.indOrKey(2))for(let e of this.indOrKey(1))f.$subcube(null,e,t,h(this.subcube(null,e,t,"array")));else if(1===t)for(let t of this.indOrKey(2))for(let e of this.indOrKey(0))f.$subcube(e,null,t,h(this.subcube(e,null,t,"array")));else for(let t of this.indOrKey(1))for(let e of this.indOrKey(0))f.$subcube(e,t,null,h(this.subcube(e,t,null,"array")))}return f});{const t=(t,e,r)=>{const i=E(t),s=i._k&&i._k[r],o=e.length;let l=!0;for(let t=0;t<o;t++){let o=e[t];if(Array.isArray(o)){const t=o.length;if(o._data_cube){for(let t=0;t<3;t++)if(t!==r&&i._s[t]!==o._s[t])throw Error("shape mismatch");if(s){if(!o._k||!o._k[r])throw Error(n.dimName[r]+" keys expected");let t=o._k[r],e=s.size;for(let r of t.keys())s.set(r,e++)}i._s[r]+=o._s[r]}else{if(0===r){if(1!==i._s[1]||1!==i._s[2])throw Error("shape mismatch");i._s[0]+=t}else if(1===r){if(i._s[0]!==t||1!==i._s[2])throw Error("shape mismatch");i._s[1]++}else{if(i._s[0]!==t||1!==i._s[1])throw Error("shape mismatch");i._s[2]++}if(s)throw Error(n.dimName[r]+" keys expected")}l=!1}else{for(let t=0;t<3;t++)if(t!==r&&1!==i._s[t])throw Error("shape mismatch");if(s)throw Error(n.dimName[r]+" keys expected");i._s[r]++}}if(s&&s.size!==i._s[r])throw Error("duplicate key");return i.length=i._s[0]*i._s[1]*i._s[2],i._data_cube=!0,[i,l]};["vert","horiz","depth"].forEach((e,r)=>{l(e,function(...e){this.toCube();const[n,i]=t(this,e,r),s=e.length,o=this.length,l=n._s[0],h=n._s[1],f=n._s[2];if(i){let t;for(t=0;t<o;t++)n[t]=this[t];for(let r=0;r<s;r++)n[t++]=e[r]}else if(0===r&&1===h&&1===f||1===r&&1===f||2===r){let t;for(t=0;t<o;t++)n[t]=this[t];for(let r=0;r<s;r++){let i=e[r];if(Array.isArray(i))for(let e=0;e<i.length;e++)n[t++]=i[e];else n[t++]=i}}else{let t=0;for(let i=-1;i<s;i++){let s=-1===i?this:e[i],o=0;if(0===r){let e=s._s[0];for(let r=0;r<f;r++){let i=r*l*h;for(let r=0;r<h;r++){let h=r*l;for(let r=0;r<e;r++)n[r+t+h+i]=s[o++]}}t+=e}else{let e=s._s[1];for(let r=0;r<f;r++){let i=r*l*h;for(let r=0;r<e;r++){let e=(r+t)*l;for(let t=0;t<l;t++)n[t+e+i]=s[o++]}}t+=e}}}return n})})}l("tile",function(t,e,r){if(this.toCube(),t=i.dim(t),e=i.nonNegInt(+u(i.single(e),2)),"full"!==(r=u(i.single(r),"full"))&&"core"!==r)throw Error("'full' or 'core' expected");const n=g(this._s);n[t]*=e;const s=n.cube();if(2===t){const t=this.length;let r=0;for(let n=0;n<e;n++)for(let e=0;e<t;e++)s[r++]=this[e]}else{const[r,n,i]=this._s,[o,l]=s._s;for(let h=0;h<e;h++){let e=0===t?h*r:h*r*n,f=0;for(let t=0;t<i;t++){let i=t*o*l;for(let t=0;t<n;t++){let n=t*o;for(let t=0;t<r;t++)s[t+e+n+i]=this[f++]}}}}return"full"===r&&(b(this,s,t),m(this,s,t)),s}),l("tileTo",function(t,e){if(this.toCube(),"full"!==(e=u(i.single(e),"full"))&&"core"!==e)throw Error("'full' or 'core' expected");if(Array.isArray(t)){if(t._data_cube){let r;for(let n=0;n<3;n++){let s=this._s[n];if(s!==t._s[n]){if(0===s)throw Error("shape mismatch");r=(r||this).tile(n,i.nonNegInt(t._s[n]/s),e)}}return r||this.copy(e)}if(1!==this._s[1]||1!==this._s[2])throw Error("shape mismatch");if(this.length===t.length)return this.copy(e);if(0===this.length)throw Error("shape mismatch");return this.tile(0,i.nonNegInt(t.length/this.length),e)}if(1!==this.length)throw Error("shape mismatch");return this.copy(e)}),l("pack",function(t,e){this.toCube(),t=i.dim(t),e=i.single(e);const r=n.shortDimName[t],s=this.key(t),o=this._s[t],l=new Array(o);let h=[1,1,1];if(h[t]=o,l.$shape(h),s){for(let t=0;t<o;t++)l[t]=this[r](s[t],e);l.$key(t,s)}else for(let t=0;t<o;t++)l[t]=this[r](t,e);const f=this.label(t);return f&&l.$label(t,f),l}),l("unpack",function(){this.toCube();const t=this.length;if(t>65536)throw Error("exceeds unpack limit of 65536 entries in outer array");let e;for(let e=0;e<t;e++)if(!Array.isArray(this[e]))throw Error("all entries must be arrays");if(1===t)e=this[0].copy();else{let r;for(let t=0;t<3;t++)if(1!==this._s[t]){if(void 0!==r)throw Error("at least 2 dimensions must have length 1");r=t}if(0===t){const t=[1,1,1];t[r]=0,e=t.cube()}else{const t=0===r?"vert":1===r?"horiz":"depth";if(this[0]._data_cube)e=this[0][t](...this.slice(1));else{const n=[this[0].length,1,1];n[r]=0,e=n.cube()[t](...this)}}}return e}),l("which",function(t){this.toCube(),t=i.single(t);const e=this.length,r=new Array(e);let n=0;if(void 0!==t){i.func(t);for(let i=0;i<e;i++)t(this[i],i,this)&&(r[n++]=i)}else for(let t=0;t<e;t++)this[t]&&(r[n++]=t);return r.length=n,r}),l("unique",function(){return this.toCube(),[...new Set(this)]}),l("isUnique",function(){return this.unique().length===this.length}),l("union",function(...t){return this.toCube(),[...new Set(this.concat(...t))]}),l("diff",function(...t){this.toCube();const e=new Set(1===t.length?c(t[0]):[].concat(...t));return this.unique().filter(t=>!e.has(t))}),l("inter",function(...t){let e=this.unique();const r=t.length;for(let n=0;n<r&&0!==e.length;n++){let r=new Set(c(t[n]));e=e.filter(t=>r.has(t))}return e}),l("isIn",function(...t){this.toCube();const e=new Set(1===t.length?c(t[0]):[].concat(...t)),r=this.copy("shell"),n=this.length;for(let t=0;t<n;t++)r[t]=e.has(this[t]);return r}),l("freq",function(t){this.toCube(),t=u(i.single(t),"matrix");const e=this.length;let r;if("vector"===t){const t=new Map,n=new Map;let i=0;for(let r=0;r<e;r++){let e=this[r],s=t.get(e);s?t.set(e,s+1):(t.set(e,1),n.set(void 0===e?"_undefined_":null===e?"_null_":e,i++))}r=[...t.values()].toCube(),d(r),r._k[0]=n}else{if("matrix"!==t)throw Error("'vector' or 'matrix' expected");{r=new Array(e);const t=new Map;let n=0;for(let i=0;i<e;i++){let e=this[i],s=t.get(e);s?t.set(e,s+1):(t.set(e,1),r[n++]=e)}r.length=2*n,r.$shape([n,2]).$key(1,["value","count"]);for(let e of t.values())r[n++]=e}}return r});{const t=(t,e,r,n)=>{const i=g(t._s);i[e]=r.length;const s=i.cube(),o=t._s[0],l=t._s[1],h=s._s[0],f=s._s[1],a=s._s[2];let u=0;if(0===e)for(let e=0;e<a;e++){let n=o*l*e;for(let e=0;e<f;e++){let i=o*e;for(let e=0;e<h;e++)s[u++]=t[r[e]+i+n]}}else if(1===e)for(let e=0;e<a;e++){let n=o*l*e;for(let e=0;e<f;e++){let i=o*r[e];for(let e=0;e<h;e++)s[u++]=t[e+i+n]}}else for(let e=0;e<a;e++){let n=o*l*r[e];for(let e=0;e<f;e++){let r=o*e;for(let e=0;e<h;e++)s[u++]=t[e+r+n]}}return b(t,s,e),m(t,s,e),n&&(t._k&&t._k[e]&&s.$key(e,t.key(e).vec(r)),t._l&&t._l[e]&&s.$label(e,t._l[e])),s};l("flip",function(e){this.toCube(),e=i.dim(e);const r=this._s[e],n=new Array(r);for(let t=0;t<r;t++)n[t]=r-1-t;return t(this,e,n,!0)}),l("roll",function(e,r){this.toCube(),e=i.dim(e),r=i.int(+u(i.single(r),1));const n=this._s[e];r<0&&(r=n- -r%n);const s=new Array(n);for(let t=0;t<n;t++)s[(t+r)%n]=t;return t(this,e,s,!0)}),l("shuffle",function(e,r){this.toCube(),e=i.dim(e);const s=this._s[e];let o;if((r=void 0===(r=i.single(r))||null===r?s:i.nonNegInt(+r))>0){if(r>s)throw Error(`cannot get ${r} shuffled ${n.dimName[e]}s `+`from dimension of length ${s}`);o=n.shuffle(s),r<s&&(o=o.slice(0,r))}else o=[];return t(this,e,o,!0)}),l("sample",function(e,r,s){this.toCube(),e=i.dim(e),r=i.nonNegInt(+u(i.single(r),1));var[s,o]=a(s);let l;const h=this._s[e];if(o)if(void 0===s||null===s)if(r>0){if(0===h)throw Error(`cannot sample ${r} ${n.dimName[e]}s `+"from empty dimension");l=1===h?[r].cube(0):[r].rand(h-1)}else l=[];else{if(1!==h)throw Error("shape mismatch");if(0===(s=i.nonNegFin(+s)))throw Error("at least one probability must be non-zero");l=[r].cube(0)}else{if(s.length!==h)throw Error("shape mismatch");if(h){for(let t=0;t<h;t++)i.nonNegFin(+s[t]);const t=s.number().cumuSum(-1),e=t[h-1];if(0===e)throw Error("at least one probability must be non-zero");l=new Array(r);for(let n=0;n<r;n++){let r=Math.random()*e;for(let e=0;e<h;e++)if(r<t[e]){l[n]=e;break}}}else{if(r)throw Error(`cannot sample ${r} ${n.dimName[e]}s from empty dimension`);l=[]}}return t(this,e,l,!1)}),l("where",function(e,r){this.toCube(),e=i.dim(e);var[r,n]=a(r);n&&("function"==typeof r&&(r=r(this),this.toCube()),r=c(r));const s=this._s[e];if(r.length!==s)throw Error("shape mismatch");const o=new Array(s);let l=0;for(let t=0;t<s;t++)r[t]&&(o[l++]=t);return o.length=l,t(this,e,o,!0)}),l("order",function(e,r,n){this.toCube(),e=i.dim(e);var[r,s]=a(r);if(s&&("function"==typeof r&&(r=r(this),this.toCube()),r=c(r)),r.length!==this._s[e])throw Error("shape mismatch");return n=i.single(n),t(this,e,A(r,n),!0)}),l("orderKey",function(e,r){if(this.toCube(),e=i.dim(e),r=i.single(r),!this._k||!this._k[e])throw Error("dimension does not have keys");const n=this.key(e),s=A(n,r),o=t(this,e,s,!1);return o.$key(e,n.vec(s)),this._l&&this._l[e]&&o.$label(e,this._l[e]),o}),l("group",function(e,r,n){this.toCube(),e=i.dim(e);var[r,o]=a(r);o&&("function"==typeof r&&(r=r(this),this.toCube()),r=c(r));const l=this._s[e],h=r.length;let f=h/l;if(![1,2,3].includes(f)){if(0!==l||0!==h)throw Error("shape mismatch");f=1}if("subcube"!==(n=u(i.single(n),"subcube"))&&"count"!==n&&"function"!=typeof n)throw Error("'subcube', 'count' or function expected");if(0===l)return[].$key(0,[]);const g=new Array(f);let p=0;for(let t=0;t<f;t++){let e=new Map;for(let t=0;t<l;t++){let n=r[p++],i=e.get(n);if(i)i[i.length]=t;else{if("_undefined_"===n||"_null_"===n)throw Error("entry has value '_undefined_' or '_null_'");e.set(n,[t])}}g[t]=e}let y=g.map(t=>t.size),_=s(new Array(l),0);for(let t=0;t<f;t++){let e=0===t?1:1===t?y[0]:y[0]*y[1],r=g[t],n=0;for(let t of r.values()){const r=t.length;for(let i=0;i<r;i++)_[t[i]]+=n*e;n++}}const b=y.cube();for(let t=0;t<l;t++){let e=_[t],r=b[e];r?r[r.length]=t:b[e]=[t]}if(d(b),g.map((t,e)=>{let r=new Map,n=0;for(let e of t.keys())void 0===e?e="_undefined_":null===e&&(e="_null_"),r.set(e,n++);b._k[e]=r}),"function"==typeof n){let r=0,i=(...i)=>{b[r]=n(t(this,e,b[r]||[],!0),...i),r++};if(1===f)for(let t of b.key(0))i(t);else if(2===f)for(let t of b.key(1))for(let e of b.key(0))i(e,t);else for(let t of b.key(2))for(let e of b.key(1))for(let r of b.key(0))i(r,e,t)}else{const r=b.length;for(let i=0;i<r;i++){let r=b[i]||[];b[i]="count"===n?r.length:t(this,e,r,!0)}}return b})}l("arrange",function(t,e){if(this.toCube(),t=i.single(t),"value"===(e=u(i.single(e),"value")))return k(g(this),t);if("index"===e)return A(this,t);if("rank"===e)return $(this,t);throw Error("'value', 'index' or 'rank' expected")}),l("bin",function(t,e,r){this.toCube();const s=(t=g(c(t))).length;if(s<2)throw Error("at least 2 bin limits expected");e=i.single(e);let o=n.comparison(e);var[r,l]=a(r);if(l){if(void 0!==r)throw Error("invalid bin names");t.sort(o),r=t}else{if(r.length!==s)throw Error("number of bin names not equal to number of bins");const n=A(t,e);t=n.map(e=>t[e]),r=n.map(t=>r[t])}if(!r.isUnique())throw Error("bin names not unique");o||(o=((t,e)=>t<=e?-1:1));const h=this.length,f=this.copy("shell");t:for(let e=0;e<h;e++){let n=this[e];for(let i=0;i<s;i++)if(o(n,t[i])<=0){f[e]=r[i];continue t}throw Error("entry not assigned to any bin")}return f});{const t=r,e=w;l("matrix",function(r,n){let s,o;if(r=i.single(r)){if(1!==this.length)throw Error("1-entry array expected");n=u(i.single(n),!0),o=e.dsvFormat(r).parseRows(t(this[0])),n&&(s=o.shift())}else o=this;const l=o.length;if(0===l)throw Error("non-empty array expected");let h,f=o[0];if(Array.isArray(f)){const t=(s||f).length;h=[l,t].cube(),s&&h.$key(1,s);for(let e=0;e<l;e++){f=o[e];for(let r=0;r<t;r++)h[e+l*r]=f[r]}}else{if("object"!=typeof f)throw Error("array or object expected");{const t=Object.keys(f),e=t.length;(h=[l,e].cube()).$key(1,t);for(let r=0;r<l;r++){f=o[r];for(let n=0;n<e;n++)h[r+l*n]=f[t[n]]}}}return h}),l("arAr",function(){let t;if(this._data_cube){const[e,r,n]=this._s;if(1!==n)throw Error("single page expected");t=new Array(e);for(let n=0;n<e;n++){let i=new Array(r);for(let t=0;t<r;t++)i[t]=this[n+e*t];t[n]=i}}else{const e=this.length;t=new Array(e);for(let r=0;r<e;r++)t[r]=[this[r]]}return t}),l("arObj",function(){if(!this._data_cube||!this._k||!this._k[1])throw Error("column keys expected");if(1!==this._s[2])throw Error("single page expected");const t=this.key(1).string();if(!t.isUnique())throw Error("two column keys convert to the same string");const[e,r]=this._s,n=new Array(e);for(let i=0;i<e;i++){let s={};for(let n=0;n<r;n++)s[t[n]]=this[i+e*n];n[i]=s}return n}),l("dsv",function(t){t=u(i.single(t),",");const r=this.arAr();if(this._data_cube&&this._k&&this._k[1]){const t=this.key(1).string();if(!t.isUnique())throw Error("two column keys convert to the same string");r.unshift(t.toArray())}return e.dsvFormat(t).formatRows(r)}),l("dict",function(t){t=i.dim(t);const e=this.length/2;if(!Number.isInteger(e))throw Error("even number of entries expected");const r=new Array(e),n=new Array(e);for(let t=0;t<e;t++)r[t]=this[2*t],n[t]=this[2*t+1];const s=[1,1,1];return s[t]=e,n.$shape(s).$key(t,r)})}l("stringify",function(){return this._data_cube?JSON.stringify({array:this,_data_cube:!0,_s:this._s,_k:this._k?this._k.map((t,e)=>this.key(e)):void 0,_l:this._l}):JSON.stringify(this)}),l("parse",function(){if(1!==this.length)throw Error("1-entry array expected");const t=JSON.parse(this[0]);if(Array.isArray(t))return t;if(t._data_cube){const e=t.array;if(e._data_cube=!0,e._s=t._s,t._k)for(let r=0;r<3;r++)t._k[r]&&e.$key(r,t._k[r]);return t._l&&(e._l=t._l.map(t=>t||void 0)),e}throw Error("serialized array or cube expected")});{const t=(t,e)=>{if(1!==t.length)throw Error("1-entry array expected");return i.string(t[0]),i.single(e)},e=t=>{if(!t.ok)throw Error(`HTTP error: ${t.status}, ${t.statusText}`)};l("fetch",function(r,n){return n=t(this,n),r=u(i.single(r),"text"),fetch(this[0],n).then(t=>(e(t),t[r]()))}),l("fetchMatrix",function(r,n){n=t(this,n);let s=this[0];const o=s.lastIndexOf("."),l=-1===o?null:s.slice(o+1).toLowerCase();let h;return"csv"===l?h=",":"tsv"===l&&(h="\t"),h&&(r=u(i.single(r),!0)),fetch(s,n).then(t=>(e(t),t[h?"text":"json"]())).then(t=>c(t).matrix(h,r))}),l("fetchParse",function(r){return r=t(this,r),fetch(this[0],r).then(t=>(e(t),t.text())).then(t=>[t].parse())})}{for(let[t,e]of[["before","_b"],["after","_a"]])l(t,function(){return this.toCube(),this[e]?this[e].copy():[0].cube()});const t=(t,e,r)=>{if(t.toCube(),0===(e=c(e)).length||1===e.length&&(void 0===e[0]||null===e[0]))delete t[r];else{for(let t of e)i.func(t);t[r]=e.copy()}return t};l("$before",function(e){return t(this,e,"_b")}),l("$after",function(e){return t(this,e,"_a")})}{const e=t=>c(t).toCube();["cube","rand","normal","seq","lin","grid","copy","toArray","matrix","arAr","arObj","dsv","dict","stringify","parse","fetch","fetchMatrix","fetchParse"].forEach(t=>{e[t]=((e,...r)=>c(e)[t](...r))}),e._assert=v,e._assert.test=((t,r,n)=>{try{r.compare(n)}catch(r){e._assert.fail(t,r.message)}}),e._assert.test.approx=((t,r,n)=>{try{r.copy("shell").compare(n.copy("shell"));const i=r.length;for(let t=0;t<i;t++)if(!(Math.abs(r[t]-n[t])<1e-12))throw Error(`entries at vector index ${t} not approximately equal`)}catch(r){e._assert.fail(t,r.message)}}),e._assert.test.throw=((t,r,n)=>{try{r.compare(n)}catch(t){return}e._assert.fail(t,"expected error but none thrown")}),t.exports=e}})()})});
