// L2 operators written in L2 rather than JavaScript.
//
// Note: code in this file CANNOT call the L2 operators
// defined here. Code is evaluated after the entire file
// has been compiled, so the new ops do not exist at
// compile time. However, the sig property of ops is
// needed at compile time. To get round this problem,
// call the relevant L2 function directly.

scope
     
  //sort rows, cols or pages based on keys
  //    X: table to sort
  //    d: dimension: 'r', 'c' or 'p'
  //    ord: order to sort in and possibly type to treat keys
  //         as, can be: 'asc' (or ~) , 'desc', 'asc-num',
  //         'desc-num', 'asc-date', 'desc-date', comparison func
  //returns sorted X
  [sortKey] X d ord
    if ord == ~ .or (ord == 'asc') .or (ord == 'desc') .or (ord.isFunc)
      KeyInd = X.key?d.sort ord
    elif ord == 'asc-num' .or (ord == 'desc-num') .or (ord == 'asc-date') .or (ord == 'desc-date') 
      direc = ord.char 0 == 'a'.alt 'asc' 'desc'
      if ord.piece h1 == 'm'
        KeyInd = X.key?d.num.sort direc 'index'
      else
        KeyInd = X.key?d.date.sort direc 'index'
    else
      'invalid argument'.error 
    if d == 'r'
      out X.r KeyInd
    elif d == 'c'
      out X.c KeyInd
    else
      out X.p KeyInd
  ~
  **
  L2.Ar.prototype.sortKey = function(d,ord) {
		if (!this[d + 'k']) throw new Error ('table does not have ' + L2.aux.expandDim[d] + ' keys');
		if (arguments.length === 2 && ord === undefined) throw new Error ('invalid argument');
    return L2_sortKey(this,d,ord) };
  L2.Ar.prototype.sortKey.sig = {arg:[1], rtn:true, min:0, dim:1};
  **
  
  [peek] X
    if X.nE == 0
      X;
    else
      X.rcp (0..(X.nR-1 <> 4)) (0..(X.nC-1 <> 4)) (0..(X.nP-1 <> 1));
    out X
  ~
  **
  L2.Ar.prototype._peek = function() { return L2_peek(this) };
  **
  
  [dictSca] Ky val
    out Ky.nE.new val.key: Ky        
  [dictTab] Ky Val
    if Val.nE == 1
      out Ky #dictSca (Val\0)
    out Val.v.key: Ky
  ~  
  **  
  L2.Ar.prototype.dict = function(x) { return (L2.aTab(x) ? L2_dictTab : L2_dictSca)(this,x) };
  L2.Ar.prototype.dict.sig = {arg:[3], rtn:true, min:0, dim:0};  
  **
  
  // Combine dictionaries A and D. Use A where shared row keys;
  // use all other extras of A.
  //    A: dict
  //    D: dict 
  // Returns new dictionary.
  [owise] A D
    if A.isDict! .or (D.isDict!)
      'dictionary expected'.error
    A = A.copy
    K = D.key.diff (A.key)
    if K.n
      A`(D.r K)
    out A    
  ~
  **
  L2.Ar.prototype._owise = function(D) { return L2_owise(this,D) };
  **

  // Rank entries of table.
  //    X: table of entries to rank - shape and extras ignored
  //    direc: valid 2nd arg to .sort: 'asc' (default), 'desc' or
  //           comparison function
  // Returns vector of ranks. Rank 0 corresponds to the first value
  // of the sorted entries (i.e. the lowest value when use 'asc')
  [rank] X direc
    SortedInd = X.sort (.nArg == 2.alt direc 'asc') 'index' //sort will check arg 
    n = X.nE
    if n == 0
      out ::
    elif n == 1
      out 0 ::
    else
      SortedVal = X.v SortedInd
      Rnk = n.new
      Rnk\0 = 0
      if direc.isFunc
        up i 1 (n-1)
          Rnk\i = SortedVal\i $direc (SortedVal\(i-1)) == 0.alt (Rnk\(i-1)) i
      elif X\0.isDate  //direc is 'asc' or 'desc' so all same type
        up i 1 (n-1)
          Rnk\i = SortedVal\i.num == (SortedVal\(i-1).num).alt (Rnk\(i-1)) i
      else
        up i 1 (n-1)
          Rnk\i = SortedVal\i == (SortedVal\(i-1)).alt (Rnk\(i-1)) i
      out n.new.v SortedInd: Rnk
  ~  
  **  
  L2.Ar.prototype.rank = function(direc) { return L2_rank(this,direc) };
  L2.Ar.prototype.rank.sig = {arg:[1], rtn:true, min:0, dim:0};  
  **    
      

  //---------- query operators ---------- 

  //sort matrix on given column
  //    X:  matrix
  //    c:  column index/key to sort on
  //    ord: 'asc', 'desc' or comparison func
  //returns matrix with same shape as X, rows sorted
  [orderScalar] X c ord
    out X.r (X.c c.sort ord 'index')
  //sort matrix on given columns
  //    X:  matrix
  //    C:  vec of column inds (non-neg) to sort on
  //          -has more than 1 entry 
  //    Ord: treated as vec, entries corresp to those of C;
  //         entries can be 'desc', 'asc' or a comparison func;
  //         if Ord has 1-entry it is used for all
  //         entries of C
  //returns matrix with same shape as X, rows sorted on
  //col in 1st entry of C, then 2nd, ...
  [orderTable] X C Ord
    if X.n == 0
      out X.copy
    if Ord.nE == 1
      Ord = C.nE.new (Ord\0)
    SortedInd = X.n.new
    next = 0
    //sort subset of row indices of X, recursive func
    //    J: subset of row indices of X
    //    cInd: index (non-neg) of C
    //returns sorted J based on vals in col (C\cInd) of X;
    //inds that corresp to same vals are boxed together;
    //pass no args to sort X on col C\0 to get started;
    //boxes than sorted recursively using other cols in C
    [subsort] J cInd
      if .nArg == 0
        cInd = 0
        c = C\0
        Ind = X.c c.sort (Ord\0) 'index'
      else  //assume both args passed
        c = C\cInd
        Ind = J.r (X.rc J c.sort (Ord\cInd) 'index')
      if Ord\cInd.isFunc
        compareFunc = Ord\cInd
      val = X\(Ind\0) c
      start = 0
      lastInd = Ind.n - 1
      IndGroup = ::
      up j 1 lastInd  //loop over Ind, group entries relating to same val
        newVal = X\(Ind\j) c
        if (compareFunc! .and (newVal < val .or (newVal > val)) .or ... //test inequality with < and > in case dates
            (compareFunc .and (val $compareFunc newVal != 0 .or (newVal $compareFunc val != 0))))
          IndGroup` ... //push box if at least 2 vals the same
            (j - start > 1.alt (Ind.slice start (j-1)[]) (Ind\start))
          val = newVal
          start = j
      IndGroup`(j - start > 1.alt (Ind.slice start (j-1)[]) (Ind\start))
      for g IndGroup  //loop over groups - which can be scalars or boxes
        if g.isBox          
          if cInd < (C.nE-1)  //sort this group using next col in C
            g[.] #subsort (cInd + 1)
          else  //sorted on all cols in C, 
            SortedInd.slice next (next + (g[.].n) - 1): (g[.])
            set next = next + (g[.].n)
        else
          SortedInd\next: g
          set next = next + 1
    subsort ##    
    out X.r SortedInd
  ~
  **
  L2.Ar.prototype.order = function(c,ord) {
    L2.assert.dataMatrix(this);
    var i, n, tmp;
    if (arguments.length === 2) {
      if (ord.v.length === 0) throw new Error('non-empty table expected');
      for (i=0, n=ord.v.length; i<n; i++) {
        tmp = ord.v[i];
        if (tmp !== 'desc' && tmp !== 'asc' && typeof tmp !== 'function') {
          throw new Error('\'asc\', \'desc\' or function expected') } } }
    else ord = new L2.ArJSA(['asc']);
    if (c.v.length === 0) throw new Error ('must specify at least 1 column');
    else if (c.v.length === 1) {
      if (ord.v.length !== 1) throw new Error(L2.errorMsg.shapeMismatch);
      return L2_orderScalar(this, c.v[0], ord.v[0]) }
    else {
      if (ord.v.length !== 1 && ord.v.length !== c.v.length) {
        throw new Error(L2.errorMsg.shapeMismatch) }
      c = L2.aux.colInd(this,c);
      //after 1st col, some entries not passed to .sort so check homog types here
      for (i=1, n=c.v.length; i<n; i++) L2.assert.homogType(this,c.v[i]);
      return L2_orderTable(this,c,ord) } };
  L2.Ar.prototype.order.sig = {arg:[2,2], rtn:true, min:1, dim:0};  
  **  
   
  //count rows where given cols have values in given bin;
  //data and limits converted to numbers - must not be NaN
  //    X: matrix
  //    C: vec, non-neg inds of cols of A to bin, pass ~ for all
  //    Limit: treated as vec, bin limits, when converted to
  //           numbers, must be strictly increasing
  //    makeKey: func to construct bin key; args are lower
  //             limit, upper limit, bin index: sc,sc,sc->sc
  //row keys of returned table are bins in asc order, counts
  //in cols
  [bin] X C Limit makeKey
    if C.isNil
      C = 0..(X.nC-1)
    Limit = Limit.v
    L = Limit.num
    nData = X.n
    nCol = C.n
    nBin = L.n - 1
    if nCol == 0
      'must specify at least 1 column (pass ~ to use all)'.error
    if nBin < 1
      'at least 1 bin (2 limits) expected'.error
    if L.isNaN.any .or (L.slice 1 h1 - (L.slice 0 h2) <= 0.any)
      'limits must convert to increasing numbers'.error
    Total = nBin,nCol.zero
    **
    var L2_z = L2_X.z;
    **
    if z
      if X.hasKeyC
        Total.keyC: (X.keyC.r C)
      Total.labelC: (X.labelC).fmtC: (X.fmtC) ...
        .keyP: (X.keyP).labelP: (X.labelP).fmtP: (X.fmtP)
    if makeKey
      Key = nBin.new
      up i 0 (nBin-1)
        Key\i: (Limit\i $makeKey (Limit\(i+1)) i)
    else
      Key = '(' + (Limit.slice 0 h2) + ',' + (Limit.slice 1 h1) + ']'
      Key\0: (Key\0.replace '(' '[')
    Total.key: Key
    if nData
      for column C
        Y = X.c column.num.asc  //.asc checks not NaN
        Count = nBin.zero
        upperInd = 1
        upper = L\upperInd
        first = 0  //first row of asc data in current bin
        if Y\0 < (L\0)
          'data value less than lowest limit'.error
        i = 0
        while i < nData
          if Y\i > upper  //save count for this bin (does not include data i), move to next
            Count\(upperInd-1): (i - first)
            first = i
            upperInd += 1
            if upperInd > nBin
              'data value greater than highest limit'.error
            upper = L\upperInd
            continue
          i = i + 1
        Count\(upperInd-1): (nData - first)
        Total.c column__index: Count
    out Total
  ~
  **
  L2.Ar.prototype.bin = function(C,Limit,makeKey) {
    L2.assert.dataMatrix(this);
    if (!L2.ge.isNil(C)) C = L2.aux.colInd(this,C);
    if (arguments.length === 3 && typeof makeKey !== 'function') {
      throw new Error('function expected') }
    return L2_bin(this,C,Limit,makeKey) };
  L2.Ar.prototype.bin.sig = {arg:[2,2,1], rtn:true, min:2, dim:0};
  **  
  
  
  //---------- pseudo-reduction operators ---------- 
  
  //quantile function
  //    X: data, treated as numbers (cannot be NaN)
  //    d: dimension - 'r', 'c', 'p' or 'e'
  //    A: probabilities, treated as numbers, must be
  //       in [0,1], shape ignored
  // linear interpolation used to compute quantiles;
  // returned table pseudo-reduced on given dim
  [quant] X d A
    A = A.num.v
    if A >= 0 && (A <= 1)!.any  //catches NaN
      'value between 0 and 1 expected'.error
    [getQuant] Y
      if Y.nE == 0
        out A.n.new NaN
      Y = Y.num.asc
      Scaled = A*(Y.n-1)
      Wt = Scaled - (Scaled.floor)
      //if any +/-Infinity entries in Y, need zeroWt*Infinity -> 0, not NaN
      if Y.e 0 == (Infinity-) .or (Y.e h1 == Infinity)
        out Y.v (Scaled.floor) * (1 - Wt).where 0 NaN: 0 + ...
           (Y.v (Scaled.ceil)  * Wt      .where 0 NaN: 0)
      else
        out Y.v (Scaled.floor) * (1 - Wt) + (Y.v (Scaled.ceil) * Wt)
    [copyExtras] dim  //copy extras for dimension dim from X to R
      if X.hasKey?dim
        R.key?dim: (X.key?dim)
      if X.label?dim
        R.label?dim: (X.label?dim)
      if X.fmt?dim
        R.fmt?dim: (X.fmt?dim)  
    if d == 'e'
      out X #getQuant.key: A
    elif d == 'r'
      if X.isVec
        R = X #getQuant.key: A
      else
        R = A.n,(X.nC),(X.nP).new.key: A
        col i X
          page j X
            R.cp i j: (X.cp i j #getQuant)
      'c' #copyExtras
      'p' #copyExtras    
    elif d == 'c'
      R = X.nR,(A.n),(X.nP).new.keyC: A
      row i X
        page j X
          R.rp i j: (X.rp i j #getQuant.tp)
      'r' #copyExtras
      'p' #copyExtras
    else  //d is 'p'
      R = X.nR,(X.nC),(A.n).new.keyP: A
      row i X
        col j X
          R.rc i j: (X.rc i j #getQuant.tp 'cpr')
      'r' #copyExtras
      'c' #copyExtras
    out R
  ~
  **
  L2.Ar.prototype.quant = function(d,A) { 
    if (arguments.length === 1) A = new L2.ArJSA([0,0.25,0.5,0.75,1]);
    return L2_quant(this,d,A) };
  L2.Ar.prototype.quant.sig = {arg:[2], rtn:true, min:0, dim:2};
  **
  
  //summary
  //    X: data
  //    d: dimension - 'r', 'c', 'p' or 'e'
  [smry] X d
    Key = 'type' :: 'finite' 'mean' 'sd' 'min' '25%' '50%' '75%' 'max'
    Qt = 0 :: 0.25 0.5 0.75 1
    [vecSmry] V  //V: entries assumed to be numbers, poss not a vec but shape ignored
      if V.isFin.allE
        out 'number' :: true (V.meanE) (V.sdE) ` (V #quant 'e' Qt)
      else
        out 'number' :: false ` (7.new '--')
    if d == 'e'
      typ = X.homogE
      R = typ == 'number'.alt (X #vecSmry) (typ,(8.new '--')).key: Key
    elif d == 'r'
      R = X.homogR ` (8 :: (X.nC) (X.nP).new '--').keyR: Key
      col c X
        page p X
          if R\0 c p == 'number'
            R.cp c p: (X.cp c p #vecSmry)
    elif d == 'c'
      R = X.homogC `` (X.nR :: 8 (X.nP).new '--').keyC: Key
      row r X
        page p X
          if R\r 0 p == 'number'
            R.rp r p: (X.rp r p #vecSmry.tp)
    else  //d is 'p'
      R = X.homogP ``` (X.nR :: (X.nC) 8.new '--').keyP: Key
      row r X
        col c X
          if R\r c 0 == 'number'
            R.rc r c: (X.rc r c #vecSmry.tp 'cpr')
    out R
  ~
  **
  L2.Ar.prototype.smry = function(d) { return L2_smry(this,d) };
  L2.Ar.prototype.smry.sig = {arg:[], rtn:true, min:0, dim:2};
  **
  
  
  //---------- covariance and correlation operators ---------- 
    
  //covariance matrix
  //    A: data
  //    normBy: if truthy normalize by A.nR, else
  //            normalize by A.nR - 1
  [cov] A normBy
    if A.n < 2
      A = A.shell NaN
    else
      A = A - (A.mean.to A)
    out A.tp.mm A / (normBy.alt (A.n) (A.n-1))
  ~
  **
  L2.Ar.prototype.cov = function(normBy) {
    if (arguments.length && normBy !== 'n') throw new Error('argument must be \'n\'');
    return L2_cov(this,normBy) }
  L2.Ar.prototype.cov.sig = {arg:[1], rtn:true, min:0, dim:0};
  **
  
  //correlation matrix
  //    A: data
  [corr] A
    A = A #cov
    StdDev = A.diag.sqrt
    out A / (StdDev.mm (StdDev.tp))
  ~
  **
  L2.Ar.prototype.corr = function() { return L2_corr(this) };
  L2.Ar.prototype.corr.sig = {arg:[], rtn:true, min:0, dim:0};
  **

  
  //---------- generate HTML strings ----------//
  
  // HTML string
  //     tag: str, HTML tag - e.g. 'div'
  //     Ops: dict of attribute name-value pairs, values can
  //          be tables (shape ignored); if attribute is 'inner',
  //          values used as contents of tags; if attribute is
  //          'n', value specifies the number of tags
  //     vec: truthy if should return vec of strings, o'wise
  //          return joined scalar string
  // Returns string (or vec of strings) of HTML. For each attribute,
  // values are recycled as reqd so as many tags as in longest entry
  // of Ops. If Ops is empty, single tag returned.
  [toHTML] tag Ops vec
    if Ops.isDict!
      'dictionary expected'.error
    isVoid = tag == ('area' :: 'base' 'br' 'col' 'embed' 'hr' 'img' 'input' ...
      'keygen' 'link' 'menuitem' 'meta' 'param' 'source' 'track' 'wbr').any
    if Ops.n
      if 'n'.in (Ops.key)
        n = Ops|'n'
        if n.isBox
          n = n\0
        n = n.num
        if n.isInt! .or (n < 0)
          '\'n\' option: non-negative integer expected'.error
      else 
        n = Ops.map {A -> A.nE}.maxE
    else
      n = 1
    S = n.new ('<' + tag)
    [addVals] k
      x = Ops\k
      if x.isBox
        X = x[.]
        if X.nE == n
          set S += X.isVec.alt X (X.v)
        else
          row j S
            S\j += X\(j % (X.nE))
      else
        set S += x
    row i Ops
      attrib = Ops.keyAt i
      if attrib == 'inner'
        inner = i
        continue
      elif attrib == 'n'
        continue
      S += ' ' + attrib + '="'
      i $addVals
      S += '"'
    S += '>'
    if inner.isNum
      if isVoid
        'cannot use \'inner\' option with this tag'.error
      inner $addVals
    if isVoid!
      S += '</' + tag + '>'
    if vec
      out S
    else
      out S.join ''.sca
  ~
  **
  L2.aux.toHTML = function(t,o,v) { return L2_toHTML(t,o,v) };
  **
  
  
  //---------- plots ----------//
  scope
    
    **
    var L2_env = env = L2.runningIn === 'nw';
    if (env) var vegaPlotNum = 0;
    **
        
    TypeLookup = << ...
      @q: 'quantitative' ...
      @t: 'temporal' ...
      @o: 'ordinal' ...
      @n: 'nominal'
    
    [expandType] t
      t = t.str
      if t.len > 1
        out t
      t = TypeLookup|t
      if t!
        'invalid 1-character channel type'
      out t
      
    [addChannel_dict] S name Op__
      if Op.hasKey 'type'
        Op@type = LHS $expandType
      S@encoding.a name = Op
    
    [addChannel_basic] S name field type
      S@encoding.a name = 'field' << field 'type' (type $expandType)
      
    // Vega-Lite spec, only dim reqd, dim and X ignored if url
    // option used.
    //    dim: 'r' 'c' 'p' or 'e'
    //    X: data 
    //    Op: options, already a dict (if passed) so do need Op__
    // Returns Vega-Lite spec.
    [spec] dim X Op
      
      //spec dict
      S = ...
        'description' << 'spec' ... 
        'data' (<<) ...
        'config' ('background' << '#fff') ...
        'mark' 'line' ...
        'encoding' (<<)
      if .nArg < 2
        out S
      
      //data
      if Op.isDict! 
        Op = <<
      if Op.hasKey 'url'
        S@data = 'url' << (Op@url)
      elif X.isNil!
        S@data = 'values' << (X.nest?dim (Op|'entry') (Op|'full'))

      //loop over options
      Op_simple = 'mark' :: 'width' 'height' 'title'.dict true
      Op_notWithUrl = 'entry' :: 'full'.dict true
      Op_plot = 'embed' :: 'put' 'richTooltip'.dict true
      Op_compose_val = 'layer' :: 'hconcat' 'vconcat' 'spec'.dict true
      for val Op
        key = Op.keyAt val__index
        if Op_simple|key
          S.a key = val
        elif Op_notWithUrl|key
          if Op.hasKey 'url'
            'cannot use \'' + key + '\' option with \'url\' option'.error
          continue //used when set data
        elif Op_plot|key
          'invalid option:  \'' + key + '\''.error
        elif key == 'url'
          continue  //used when set data
        elif key == 'compose' //Op_comp|key
          if Op_compose_val|val!
            'invalid \'comp\' option'.error 
          compose = val
        else  //assume a channel
          if val.isBox
            V = val[.]
            if V.n == 0
              'at least one value expected (channel option \'' + key + '\')'.error
            if V.isDict
              S #addChannel_dict key V
            elif V.n == 1
              S $addChannel_basic key (V\0) 'quantitative'
            elif V.n == 2
              S $addChannel_basic key (V\0) (V\1 $expandType)
            else
              'dictionary expected (channel option \'' + key + '\', more than 2 entries)'.error
          else
            S $addChannel_basic key val 'quantitative'

      //channel defaults
      if S@data[.].hasKey 'values' .and (S@encoding[.].n == 0) .and (X\0.isBox!)
        Data = S@data@values[.]
        if Data.n == 0
          out S
        Field = Data\0[.].key
        nF = Field.n
        mark = S@mark
        if mark.in ('area' :: 'bar' 'circle' 'line' 'point' 'rect' 'square')
          xType = mark.in ('bar' :: 'rect').alt 'n' 'q'
          yType = mark == 'rect'.alt 'n' 'q'
          S $addChannel_basic 'y' (Field\0) yType
          if dim == 'e'
            if nF > 1
              S $addChannel_basic 'x' (Field\1) xType
              if nF > 2
                S $addChannel_basic 'color' (Field\2) 'n'
          else
            nMainDim = X.n?dim
            if nF > nMainDim  //extra fields added
              S $addChannel_basic 'x' (Field\nMainDim) xType  //first extra field
            if nMainDim > 1
              S $addChannel_basic 'color' (Field\1) 'n'
        elif mark.in ('rule' :: 'tick')
          S $addChannel_basic 'x' (Field\0) 'q'
          if nF > 1
            S $addChannel_basic (mark == 'rule'.alt 'color' 'y') (Field\1) 'n'
            
      //composition
      if compose
        Tmp = 'mark' << (S@mark) 'encoding' (S@encoding) 
        S.a compose = compose == 'spec'.alt (Tmp[]) (Tmp[][])
        S.r ('mark' :: 'encoding') 'cut'
   
      out S
    ~
    **
    L2.Ar.prototype.spec = function(d,...op) { return L2_spec(d, this, L2.aux.pair(op)) };
    L2.Ar.prototype.spec.sig = {arg:false, rtn:true, min:0, dim:2};
    **
        
    EmbedDef = ...
      '$schema' << 'https://vega.github.io/schema/vega-lite/v2.json' ...
      'mode' 'vega-lite' ...
      'actions' false
        
    // Plot.
    //    dim: 'r' 'c' 'p' or 'e' (ignored if X is a spec)
    //    X: data or spec
    //    Op: options, already a dict so do need Op__
    // Returns spec.
    [plot] dim X Op
      
      //options
      Op = Op.isDict.alt (Op.copy 'deep') (<<) .owise ...  //copy Op since change it below
        'put' '' ...
        'embed' EmbedDef ...
        'richTooltip' true
      OpPlot = ... //cut out plot ops so Op has only spec ops  
        Op.r ('put' :: 'embed' 'richTooltip') 'cut'
      put = OpPlot@put
      if env .and (put.in (1..4))
        panel = true
        if OpPlot@embed@mode != 'vega-lite'
          'the plot panel can only display Vega-Lite plots'.error
        
      //spec
      if X.isDict .and ... //check if already a spec or 'wrapped spec' (used with 'facet', 'repeat' etc) 
          (X|'description' == 'spec' .or ...
          (X|'spec'.isBox .and (X@spec[.].isDict) .and (X@spec|'description' == 'spec')))  
        if Op.n != 0
          'invalid option \'' + (Op.keyAt 0) + '\' (cannot pass spec and spec options)'.error      
      else
        X = spec ## dim X Op
      
      //draw plot
      ~
      **
      if (L2_panel) {
        L2.ide.vegaData[L2_put-1] = L2.toJS(L2_X);
        L2.aux.drawPlot(L2_put-1) }      
      else L2.aux.drawPlot(L2.toJS(L2_X), L2.toJS(L2_OpPlot,'allow'));
      **
      out X
    ~
    **
    L2.Ar.prototype.plot = function(d,...op) { return L2_plot(d, this, L2.aux.pair(op)) };
    L2.Ar.prototype.plot.sig = {arg:false, rtn:true, min:0, dim:2};

    // Create plot.
    //    x: jso representing a spec or: 
    //       int in [0..3] - only in env, plot to pane x of panel
    //    op: jso, plot options - ignored if plotting to panel      
    // Returns undefined.
    L2.aux.drawPlot = (x,op) => {
      if (!env && L2.runningIn !== 'wp') return;
      var put, embed, richTooltip, trgt, panel, spec, el;
      if (typeof x === 'object') {  //plot to console or in HTML doc
        spec = x;
        ({put, embed, richTooltip} = op);
        if (env) trgt = document.getElementById('oput') }
      else {  //panel
        spec = L2.ide.vegaData[x];
        panel = true;
        put = x;
        embed = L2.toJS(L2_EmbedDef);
        embed.padding = {left: 10, top: 10, right: 10, bottom: 10};
        richTooltip = true;
        trgt = document.getElementById('pl_' + put);
        trgt.innerHTML = '';
        spec.autosize = 'fit';
        spec.width = trgt.clientWidth - 19;  //1px larger then should be - no risk of lines between plots
        spec.height = trgt.clientHeight - 19 }
        
      if (env) {
        trgt.insertAdjacentHTML('beforeend',
          '<div class="L2VegaWrapper' + (panel ? 'Panel' : '') +'"><div id="vegaPlot_' + 
          (vegaPlotNum++) + '"></div></div><br>');
        el = '#vegaPlot_' + (vegaPlotNum-1) }
      else {
        el = embed.put;
        if (typeof el === 'string') el = L2.html(document.querySelectorAll(el)); 
        else if (typeof el !== 'function' || !el._html_) throw new Error('string or element list expected');
        if (!el._html_.size) throw new Error('empty element list');
        el = el._html_._elmt(0);
      }    
      var scrollConsole = () => $('#co_in').scrollTop(10e10).scrollLeft(0);	 //jQ available in env
      vegaEmbed(el, spec, embed).then( function(result) {
        if (richTooltip) vegaTooltip.vegaLite(result.view, spec, richTooltip);
        if (env) scrollConsole() } )
      .catch( function(err) { //error, catch it or can prevent vega displaying future plots
        if (env) {
          if (panel) {
            trgt.innerHTML = '';
            L2.ide.vegaData[put] = undefined }
          document.getElementById('oput').insertAdjacentHTML('beforeend',
            '<div class="noIndent L2Other">Problem drawing Vega plot:<br>' + 
            L2.aux.specChar(err.message) + '</div><br>');            
          scrollConsole() }
        else console.log('Problem drawing Vega plot:\n' + err.message) } );
    }
    **   


